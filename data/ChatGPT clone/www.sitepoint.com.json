{
    "summary": "SitePoint\n\n  *   * Blog\n  *     * Free Tech Books \u2192\n    * AI \u2192\n    * JavaScript \n    * Computing \n    * Design & UX \n    * HTML & CSS \n    * Entrepreneur \n    * Web \n    * PHP \n    * WordPress \n    * Mobile \n    * Programming \n    * Python \u2192\n  * Forum\n  * Library\n  * Login\n  * Join Premium\n\nJoin Premium\n\n  * Free Tech Books\n  * AI\n  * JavaScript\n  * Computing\n  * Design & UX\n  * HTML & CSS\n  * Entrepreneur\n  * Web\n  * PHP\n  * WordPress\n  * Mobile\n  * Programming\n  * Python\n\nAI\n\n# Build Your Own ChatGPT Clone with React and the OpenAI API\n\nMadars BissSeptember 21, 2023\n\nShare\n\n**In this tutorial, we\u2019ll walk through how to build a custom Chatbot\napplication that will allow us to ask questions and receive high-quality\nanswers. The bot will remember previous prompts, simulating context-aware\nconversation.**\n\nChatbots have become indispensable tools for businesses and developers seeking\nto improve customer interactions and streamline user experiences in today\u2019s\nrapidly evolving digital landscape.\n\nOpenAI\u2019s ChatGPT has transformed from a cutting-edge experiment into a\npowerhouse in chatbot development. Its meteoric rise to success is nothing\nshort of remarkable, captivating users worldwide.\n\n_The demo code of this project is available onCodeSandbox. You\u2019ll have to\nprovide your own OpenAI API key in the `.env` file to test it live. To get\none, create an account on the OpenAI, log in, navigate to the API keys and\ngenerate a new API key._\n\nTable of Contents\n\n  * Planning Features and UI\n  * Picking a Color Scheme\n  * Setting Up the React App\n  * Adding Global Styles\n  * Downloading the Media\n  * Building the Components\n    * The Message component\n    * The Input component\n    * The History component\n    * The Clear component\n  * Building the User Interface\n  * Creating the App Layout\n  * Getting the API Key from OpenAI\n  * Preparing the Request Call to OpenAI API\n  * Testing the Application\n  * Conclusion\n\n## Planning Features and UI\n\nOur application will be based on React, and we\u2019ll use OpenAI API to access the\ndata and use CSS modules for styling.\n\nUtilizing React will allow us to create a dynamic and responsive user\ninterface, enhancing the overall user experience.\n\nThe OpenAI API will let us gain access to advanced language processing\ncapabilities, providing data for creating insightful interactions.\n\nAdditionally, CSS modules will allow us to maintain a modular design,\nfacilitating efficient development and customization of the app.\n\nThe features we\u2019ll be implementing include:\n\n  * A designated input area where users will be able to craft prompts, inviting contextually relevant inquiries.\n  * A **Submit** button that will allow users to submit their prompts to the API, initiating the conversation process.\n  * Message items that will be showcased as chat-style messages within the conversation window, enhancing the interactive chat experience.\n  * Message items to display ChatGPT replies that will provide a conversational flow.\n  * A **History** feature that will list all of the user\u2019s recent prompts. This will also allow users to revisit previous conversations.\n  * A **Clear** button that will allow the removal of generated content, offering a clean slate for new conversations.\n\nThe image below shows our component-based wireframe.\n\nThe whole application will be wrapped in the main container, which will hold\nall of the elements together. It will be further divided into a two-column\nlayout.\n\nThe first column will include all of the messages from the user and ChatGPT.\nAt the bottom of the column, there will be an input area and a button for\nsubmitting the prompt.\n\nThe second column will hold the history of all of the recent prompts. At the\nbottom of the column, there will be a **Clear** button that will allow the\nuser to wipe the generated content.\n\n## Picking a Color Scheme\n\nThe application design will prioritize the ease of content perception. This\nwill allow us to provide a couple of important benefits:\n\n  * Users will be able to quickly comprehend the presented information, leading to a more intuitive and user-friendly experience.\n  * It will also enhance accessibility, ensuring that individuals of varying backgrounds and abilities will be able to easily navigate and engage with the content.\n\nThe image below shows our color scheme.\n\nThe background of the application will be black, while the messages, history\nitems, and input form will be dark gray.\n\nThe text on the messages and input backgrounds will be white, providing a nice\ncontrast and make text easy to read.\n\nTo give the app some highlights, the column titles, **Submit** button, and\nresponse message avatars will use a bright, lime-green tone.\n\nTo accent the **Clear** button, a mild red tone will be used. This will also\nhelp users avoid clicking the button accidentally.\n\n## Setting Up the React App\n\nWe\u2019ll use create-react-app to create our application. Run `npx create-react-\napp react-chatgpt` to create a new React project.\n\nWait for a minute for the setup to complete, and then change the working\ndirectory to the newly created folder by `cd react-chatgpt` and run `npm\nstart` to start the developer server.\n\nThis should open up our project in our default browser. If not, navigate to\nhttp://localhost:3000 to open it manually. We should be presented with the\nReact welcome screen, as pictured below.\n\n## Adding Global Styles\n\nWe\u2019ll add global styling to establish a consistent and unified visual\nappearance across all components of the application.\n\nOpen `index.css` and include the following styling rules:\n\n    \n    \n    @import url(\"https://fonts.googleapis.com/css2?family=Varela+Round&display=swap\");\n    \n    * {\n      margin: 0;\n      padding: 0;\n      box-sizing: border-box;\n      font-family: \"Varela Round\", sans-serif;\n    }\n    \n    body {\n      background-color: #121212;\n    }\n    \n\nFirst, we import the Varela Round font and set the whole app to use it.\n\nWe also remove any pre-defined margins and paddings, as well as set `box-\nsizing` to `border-box` so the app looks the same on different browsers.\n\nFinally, we set the background of the body to a dark tone, which allows us to\nhighlight the content of the application.\n\n## Downloading the Media\n\nWe\u2019ll need a couple of avatars to represent the authors of the messages from\nthe user and OpenAI API. This way, they\u2019ll be easier to distinguish.\n\nCreate a new `icons` folder inside the `src` directory and include the\n`bot.png` and `user.png` icons.\n\n_You can download samples from`icons` directory here, or you can use custom\nones from sites like FlatIcon or Icons8, as long as you keep the above file\nnames._\n\n## Building the Components\n\nFirst, we need a well-organized file structure that matches the wireframe\ndesign.\n\nWe\u2019ll use the terminal to create the necessary folder and component files.\nEach component will have its own JavaScript file for functionality and CSS\nfile for styling.\n\nChange the working directory in the `src` folder by running `cd src` and then\nrun the following command:\n\n    \n    \n    mkdir components && cd components && touch Message.js Message.module.css Input.js Input.module.css History.js History.module.css Clear.js Clear.module.css\n    \n\nThe command above will first create a `/components/` folder, then change the\nworking directory to it, and create all the necessary files inside it.\n\n### The Message component\n\nThe `Message` component will display user prompts and API responses within the\nconversation, facilitating the real-time exchange of information between the\nuser and the chatbot.\n\nOpen the `Message.js` file and include the following code:\n\n    \n    \n    import bot from \"../icons/bot.png\";\n    import user from \"../icons/user.png\";\n    \n    import styles from \"./Message.module.css\";\n    \n    export default function Message({ role, content }) {\n      return (\n        <div className={styles.wrapper}>\n          <div>\n            <img\n              src={role === \"assistant\" ? bot : user}\n              className={styles.avatar}\n              alt=\"profile avatar\"\n            />\n          </div>\n          <div>\n            <p>{content}</p>\n          </div>\n        </div>\n      );\n    }\n    \n\nFirst, we import the downloaded icons for avatars and then import the external\nCSS rules for styling.\n\nAfter that, we create the wrapper for the `Message` component, which will\ncontain both icons and text content.\n\nWe use the `role` prop in the conditional to display the appropriate avatar as\nthe image `src`.\n\nWe also use the `content` prop, which will be passed in as the text response\nfrom the OpenAI API and user input prompt.\n\nNow let\u2019s style the component so it looks like a chat message! Open the\n`Message.module.css` file and include the following rules:\n\n    \n    \n    .wrapper {\n      display: grid;\n      grid-template-columns: 60px auto;\n      min-height: 60px;\n      padding: 20px;\n      margin-bottom: 20px;\n      border-radius: 10px;\n      background-color: #1b1b1d;\n    }\n    \n    .avatar {\n      width: 40px;\n      height: 40px;\n    }\n    \n\nWe divide the layout into two columns, with the avatars shown in the fixed-\nwidth container on the right and the text on the left.\n\nNext, we add some padding and margin to the bottom of the message. We also\nstyle the message to have round borders and set the background to dark gray.\n\nFinally, we set the avatar icon to a fixed width and height.\n\n### The Input component\n\nThe `Input` component will be an interface element designed to capture user\nqueries, serving as the means through which users interact and engage with the\nchatbot.\n\nOpen the `Input.js` file and include the following code:\n\n    \n    \n    import styles from \"./Input.module.css\";\n    \n    export default function Input({ value, onChange, onClick }) {\n      return (\n        <div className={styles.wrapper}>\n          <input\n            className={styles.text}\n            placeholder=\"Your prompt here...\"\n            value={value}\n            onChange={onChange}\n          />\n          <button className={styles.btn} onClick={onClick}>\n            Go\n          </button>\n        </div>\n      );\n    }\n    \n\nWe first import the external stylesheet to style the component.\n\nWe return the component wrapper that includes the input field for the user\nprompts and the button to submit it to the API.\n\nWe set the placeholder value to be displayed when the input form is empty, and\ncreate the `value` prop to hold the entered prompt, as well as the `onChange`\nprop that will be called once the input value changes.\n\nFor the button, the `onClick` prop will be called once the user clicks on the\nbutton.\n\nNow let\u2019s style the component so that the input area looks beautiful and the\nuser is encouraged to provide prompts! Open the `Input.module.css` file and\ninclude the following rules:\n\n    \n    \n    .wrapper {\n      display: grid;\n      grid-template-columns: auto 100px;\n      height: 60px;\n      border-radius: 10px;\n      background-color: #323236;\n    }\n    \n    .text {\n      border: none;\n      outline: none;\n      background: none;\n      padding: 20px;\n      color: white;\n      font-size: 16px;\n    }\n    \n    .btn {\n      border: none;\n      border-radius: 0 10px 10px 0;\n      font-size: 16px;\n      font-weight: bold;\n      background-color: rgb(218, 255, 170);\n    }\n    \n    .btn:hover {\n      cursor: pointer;\n      background-color: rgb(200, 253, 130);\n    }\n    \n\nWe set the wrapper to be divided into two columns, with a fixed width for the\nbutton and the rest of the available width dedicated to the input area.\n\nWe also define the specific height of the component, set the rounded borders\nfor it, and set the background to dark gray.\n\nFor the input area, we remove the default border, outline, background and add\nsome padding. We set the text color to white and set a specific font size.\n\n### The History component\n\nThe `History` component will display the sequence of past user and chatbot\ninteractions, providing users with a contextual reference of their\nconversation.\n\nOpen the `History.js` file and include the following code:\n\n    \n    \n    import styles from \"./History.module.css\";\n    \n    export default function History({ question, onClick }) {\n      return (\n        <div className={styles.wrapper} onClick={onClick}>\n          <p>{question.substring(0, 15)}...</p>\n        </div>\n      );\n    }\n    \n\nWe first import the external style rules for the component. Then we return the\nwrapper that will include the text.\n\nThe text value will be passed in as a `question` prop from the user prompt,\nand only the first 15 characters of the text string will be displayed.\n\nUsers will be allowed to click on the history items, and we\u2019ll pass the\n`onClick` prop to control the click behavior.\n\nNow let\u2019s style the component to ensure it\u2019s visually appealing and fits well\nin the sidebar! Open the `History.module.css` file and include the following\nrules:\n\n    \n    \n    .wrapper {\n      padding: 20px;\n      margin-bottom: 20px;\n      border-radius: 10px;\n      background-color: #1b1b1d;\n    }\n    \n    .wrapper:hover {\n      cursor: pointer;\n      background-color: #323236;\n    }\n    \n\nWe set some padding, add the margin to the bottom, and set the rounded corners\nfor the history items. We also set the background color to dark gray.\n\nOnce the user hovers over the item, the cursor will change to a pointer and\nthe background color will change to a lighter shade of gray.\n\n### The Clear component\n\nThe `Clear` component will be a UI element designed to reset or clear the\nongoing conversation, providing users with a quick way to start a new\ninteraction without navigating away from the current interface.\n\nOpen the `Clear.js` file and include the following code:\n\n    \n    \n    import styles from \"./Clear.module.css\";\n    \n    export default function Clear({ onClick }) {\n      return (\n        <button className={styles.wrapper} onClick={onClick}>\n          Clear\n        </button>\n      );\n    }\n    \n\nWe first import the external stylesheet to style the component.\n\nWe return the button that will allow users to clear the content of the\napplication. We\u2019ll pass the `onClick` prop to achieve the desired behavior.\n\nNow let\u2019s style the component to make it stand out and reduce the chances of\nusers pressing it accidentally! Open the `Clear.module.css` file and include\nthe following rules:\n\n    \n    \n    .wrapper {\n      width: 100%;\n      height: 60px;\n      background-color: #ff9d84;\n      border: none;\n      border-radius: 10px;\n      font-size: 16px;\n      font-weight: bold;\n    }\n    \n    .wrapper:hover {\n      cursor: pointer;\n      background-color: #ff886b;\n    }\n    \n\nWe set the button to fill the available width of the column, set the specific\nheight, and set the background color to mild red.\n\nWe also remove the default border, set the rounded corners, set a specific\nfont size, and make it bold.\n\nOn hover, the cursor will change to a pointer and the background color will\nchange to a darker shade of red.\n\n## Building the User Interface\n\nIn the previous section, we built all of the necessary components. Now let\u2019s\nput them together and build the user interface for the application.\n\nWe\u2019ll configure their functionality to create a functional and interactive\nchatbot interface with organized and reusable code.\n\nOpen the `App.js` file and include the following code:\n\n    \n    \n    import { useState } from \"react\";\n    \n    import Message from \"./components/Message\";\n    import Input from \"./components/Input\";\n    import History from \"./components/History\";\n    import Clear from \"./components/Clear\";\n    \n    import \"./styles.css\";\n    \n    export default function App() {\n      const [input, setInput] = useState(\"\");\n      const [messages, setMessages] = useState([]);\n      const [history, setHistory] = useState([]);\n    \n      return (\n        <div className=\"App\">\n          <div className=\"Column\">\n            <h3 className=\"Title\">Chat Messages</h3>\n            <div className=\"Content\">\n              {messages.map((el, i) => {\n                return <Message key={i} role={el.role} content={el.content} />;\n              })}\n            </div>\n            <Input\n              value={input}\n              onChange={(e) => setInput(e.target.value)}\n              onClick={input ? handleSubmit : undefined}\n            />\n          </div>\n          <div className=\"Column\">\n            <h3 className=\"Title\">History</h3>\n            <div className=\"Content\">\n              {history.map((el, i) => {\n                return (\n                  <History\n                    key={i}\n                    question={el.question}\n                    onClick={() =>\n                      setMessages([\n                        { role: \"user\", content: history[i].question },\n                        { role: \"assistant\", content: history[i].answer },\n                      ])\n                    }\n                  />\n                );\n              })}\n            </div>\n            <Clear onClick={clear} />\n          </div>\n        </div>\n      );\n    }\n    \n\nFirst, we import the `useState` hook that we\u2019ll use to track the data state\nfor the application. Then we import all the components we built and the\nexternal stylesheet for styling.\n\nThen we create the `input` state variable to store the user prompt input,\n`messages` to store the conversation between the user and ChatGPT, and\n`history` to store the history of user prompts.\n\nWe also create the main wrapper for the whole app that will hold two columns.\n\nEach column will have a title and content wrapper that will include the\nconversation messages, input area, and **Submit** button for the first column\nand history items and the **Clear** button for the second column.\n\nThe conversation messages will be generated by mapping through the `messages`\nstate variable and the history items \u2014 by mapping through the `history` state\nvariable.\n\nWe set the input `onChange` prop to update the `input` state variable each\ntime user enters any value in the input form.\n\nOnce the user clicks the **Send** button, the user prompt will be sent to the\nOpenAI API to process and receive the reply.\n\nFor the history items, we set the `onClick` prop so that the `messages` state\nvariable gets updated to the specific prompt and answer.\n\nFinally, for the **Clear** button, we pass the `onClick` prop a function that\nwill clear both the message and history values, clearing the application data.\n\n## Creating the App Layout\n\nIn this section, we\u2019ll arrange the user interface components to create an\nintuitive structure for effective user interaction.\n\nOpen `App.css` and include the following styling rules:\n\n    \n    \n    .App {\n      display: grid;\n      grid-template-columns: auto 200px;\n      gap: 20px;\n      max-width: 1000px;\n      margin: 0 auto;\n      min-height: 100vh;\n      padding: 20px;\n    }\n    \n    .Column {\n      color: white;\n    }\n    \n    .Title {\n      padding: 20px;\n      margin-bottom: 20px;\n      border-radius: 10px;\n      color: black;\n      background-color: rgb(218, 255, 170);\n    }\n    \n    .Content {\n      height: calc(100vh - 200px);\n      overflow-y: scroll;\n      margin-bottom: 20px;\n    }\n    \n    ::-webkit-scrollbar {\n      display: none;\n    }\n    \n\nWe split the main app wrapper into two columns, separated by a gap by using\nCSS grid layout, and we set the left column for history items to a fixed\nwidth.\n\nNext, we set the wrapper to never exceed a certain width, center it on the\nscreen, make it use all of the screen viewport height, and add some padding\ninside it.\n\nFor each column\u2019s contents, we set the text color to white.\n\nFor the column titles, we set some padding, add the bottom margin, and set the\nrounded corners. We also set the title element background color to lime-green\nand set the text color to black.\n\nWe also style the columns themselves by setting the rule that the content\nshouldn\u2019t exceed a certain height and set the content to be scrollable if it\nreaches outside the height. We also add a margin to the bottom.\n\nWe also hide the scrollbars, so that we don\u2019t have to style them to override\nthe default values for each browser. This rule is optional and we could leave\nit out.\n\n## Getting the API Key from OpenAI\n\nIf you haven\u2019t already set up your own API key for the Sandbox in the\nintroduction of this tutorial, make sure to create an account on the OpenAI\nwebsite.\n\nNext, log in and navigate to the API keys and generate a new API key.\n\nCopy the key to the clipboard and open your project.\n\nCreate a new `.env` file in your project root and paste the value for the\nfollowing key like so:\n\n    \n    \n    REACT_APP_OPENAI_API_KEY=paste-your-code-here\n    \n\n## Preparing the Request Call to OpenAI API\n\nThrough the OpenAI API, our chatbot will be able to send textual prompts to\nthe OpenAI server, which will then process the input and generate human-like\nresponses.\n\nThis is achieved by leveraging a powerful language model that\u2019s been trained\non diverse text sources. By providing the model with a conversation history\nand the current user prompt, our chatbot will receive context-aware responses\nfrom the API.\n\nIn this section, we\u2019ll prepare the request and implement the call to the API\nto receive the response and set the data to the state variable we defined\nearlier.\n\nOpen the `App.js` again and add the following code:\n\n    \n    \n    // imported modules ...\n    \n    export default function App() {\n      // useState variables ...\n    \n      const handleSubmit = async () => {\n        const prompt = {\n          role: \"user\",\n          content: input,\n        };\n    \n        setMessages([...messages, prompt]);\n    \n        await fetch(\"https://api.openai.com/v1/chat/completions\", {\n          method: \"POST\",\n          headers: {\n            Authorization: `Bearer ${process.env.REACT_APP_OPENAI_API_KEY}`,\n            \"Content-Type\": \"application/json\",\n          },\n          body: JSON.stringify({\n            model: \"gpt-3.5-turbo\",\n            messages: [...messages, prompt],\n          }),\n        })\n          .then((data) => data.json())\n          .then((data) => {\n            const res = data.choices[0].message.content;\n            setMessages((messages) => [\n              ...messages,\n              {\n                role: \"assistant\",\n                content: res,\n              },\n            ]);\n            setHistory((history) => [...history, { question: input, answer: res }]);\n            setInput(\"\");\n          });\n      };\n    \n      const clear = () => {\n        setMessages([]);\n        setHistory([]);\n      };\n    \n      return <div className=\"App\">// returned elements ...</div>;\n    }\n    \n\nFirst, we create a separate `handleSubmit` function, which will be executed\nonce the user has entered the prompt in the input form and clicks the\n**Submit** button.\n\nInside `handleSubmit`, we first create the `prompt` variable that will hold\nthe role `user` and the prompt itself as an object. The role is important\nbecause, when storing our messages, we\u2019ll need to know which ones are user\nmessages.\n\nThen we update the `messages` state variable with the user prompt.\n\nNext, we make an actual `fetch` call to the api.openai.com/v1/chat/completions\nendpoint to access the data from the OpenAI API.\n\nWe specify that it\u2019s a `POST` request, and set the headers with the\nauthorization token and the content type. For the `body` parameters, we\nspecify which API model to use, and we pass the `messages` variable as the\ncontent from the user.\n\nOnce the response is received, we store it in the `res` variable. We add the\nobject consisting of the role `assistant` and the response itself to the\n`message` state variable.\n\nWe also update the `history` state variable with the object, with the\n`question` and corresponding `answer` as the keys.\n\nAfter the response is received and state variables are updated, we clear the\n`input` state variable to prepare the input form for the next user prompt.\n\nFinally, we create a simple `clear` function to clear the `messages` and\n`history` state variables, allowing the user to clear the data of the\napplication.\n\n## Testing the Application\n\nAt this point, we should have created a fully functional chat application! The\nlast thing left to do is to test it.\n\nFirst, let\u2019s try to ask ChatGPT a single question.\n\nThe animation above shows a question being submitted and an answer being\nreceived.\n\nNow let\u2019s try to create a conversation.\n\nAs shown in the animation above, the chatbot remembers the context from the\nprevious messages, so we can speak with it while being fully context-aware.\n\nNow let\u2019s see what happens once we click on the **History** button.\n\nNotice how the chat switches to the respective user prompt and answer. This\ncould be useful if we want to resume the conversation from a specific point.\n\nFinally, let\u2019s click on the **Clear** button.\n\nAs expected, the contents of the app are cleared. This is a useful option when\nthere\u2019s a lot of content and the user wants to start fresh.\n\n## Conclusion\n\nIn this tutorial, we\u2019ve learned how to create an easy-to-use user interface,\nhow to structure our code via components, how to work with states, how to make\nAPI calls, and how to process the received data.\n\nWith the combination of advanced natural language processing capabilities of\nthe OpenIAI API and the flexibility of React, you\u2019ll now be able to create\nsophisticated chatbot applications that you can customize further to your\nliking.\n\nNotice that this tutorial stores the API key on the frontend, which might not\nbe secure for production. If you want to deploy the project, it would be\nadvisable to create an Express server and use the API key there.\n\nAlso, if you want the history prompts to be available after the next initial\nlaunch, you could store and then read them from local storage, or even connect\na database to your app and store and read data from there.\n\n## Share This Article\n\nMadars Biss\n\nMadars Biss (also known as Madza) is a passionate software developer and\ncontent creator for SitePoint.\n\nchatbotchatGPTopenaiopenai api\n\n## Up Next\n\nHow to Build a Simple Spellchecker with ChatGPTJames Charlesworth\n\nHow to Perform Data Analysis in Python Using the OpenAI APIMatt Nikonorov\n\nCreate a Chatbot Trained on Your Own Data via the OpenAI APIMatt Nikonorov\n\nBuild Your First JavaScript ChatGPT PluginMark O'Neill\n\nBuild a Hacker News Clone using React and HarperDBKingsley Ubah\n\nHow to Create a Reddit Clone Using React and FirebaseNirmalya Ghosh\n\n  * ## Stuff we do\n\n  * Premium\n  * Newsletters\n  * Forums\n\n  * ## About\n\n  * Our story\n  * Terms of use\n  * Privacy policy\n  * Corporate memberships\n\n  * ## Contact\n\n  * Contact us\n  * FAQ\n  * Publish your book with us\n  * Write an article for us\n  * Advertise\n\n  * ## Connect\n\n  * \n\n\u00a9 2000 \u2013 2024 SitePoint Pty. Ltd.\n\nThis site is protected by reCAPTCHA and the Google Privacy Policy and Terms of\nService apply.\n\n<img height=\"1\" width=\"1\" style=\"display:none\"\nsrc=\"https://www.facebook.com/tr?id=721455246308784&ev=PageView&noscript=1\"}\n/>\n\n",
    "links": "[{\"link\": \"https://www.sitepoint.com/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/blog/\", \"text\": \"Blog\"}, {\"link\": \"https://www.sitepoint.com/premium/library/free/?ref_source=blog_nav\", \"text\": \"Free Tech Books \u2192\"}, {\"link\": \"https://www.sitepoint.com/ai/\", \"text\": \"AI \u2192\"}, {\"link\": \"https://www.sitepoint.com/javascript/\", \"text\": \"JavaScript \"}, {\"link\": \"https://www.sitepoint.com/computing/\", \"text\": \"Computing \"}, {\"link\": \"https://www.sitepoint.com/design-ux/\", \"text\": \"Design & UX \"}, {\"link\": \"https://www.sitepoint.com/html-css/\", \"text\": \"HTML & CSS \"}, {\"link\": \"https://www.sitepoint.com/entrepreneur/\", \"text\": \"Entrepreneur \"}, {\"link\": \"https://www.sitepoint.com/web/\", \"text\": \"Web \"}, {\"link\": \"https://www.sitepoint.com/php/\", \"text\": \"PHP \"}, {\"link\": \"https://www.sitepoint.com/wordpress/\", \"text\": \"WordPress \"}, {\"link\": \"https://www.sitepoint.com/mobile/\", \"text\": \"Mobile \"}, {\"link\": \"https://www.sitepoint.com/programming/\", \"text\": \"Programming \"}, {\"link\": \"https://www.sitepoint.com/python/\", \"text\": \"Python \u2192\"}, {\"link\": \"https://www.sitepoint.com/community/\", \"text\": \"Forum\"}, {\"link\": \"https://www.sitepoint.com/premium/library/\", \"text\": \"Library\"}, {\"link\": \"https://www.sitepoint.com/premium/sign-in/\", \"text\": \"Login\"}, {\"link\": \"https://www.sitepoint.com/premium/pricing/?ref_source=sitepoint&ref_medium=topnav\", \"text\": \"Join Premium\"}, {\"link\": \"https://www.sitepoint.com/premium/pricing/?ref_source=sitepoint&ref_medium=topnav\", \"text\": \"Join Premium\"}, {\"link\": \"https://www.sitepoint.com/premium/library/free/?ref_source=blog_nav\", \"text\": \"Free Tech Books\"}, {\"link\": \"https://www.sitepoint.com/ai/\", \"text\": \"AI\"}, {\"link\": \"https://www.sitepoint.com/javascript/\", \"text\": \"JavaScript\"}, {\"link\": \"https://www.sitepoint.com/computing/\", \"text\": \"Computing\"}, {\"link\": \"https://www.sitepoint.com/design-ux/\", \"text\": \"Design & UX\"}, {\"link\": \"https://www.sitepoint.com/html-css/\", \"text\": \"HTML & CSS\"}, {\"link\": \"https://www.sitepoint.com/entrepreneur/\", \"text\": \"Entrepreneur\"}, {\"link\": \"https://www.sitepoint.com/web/\", \"text\": \"Web\"}, {\"link\": \"https://www.sitepoint.com/php/\", \"text\": \"PHP\"}, {\"link\": \"https://www.sitepoint.com/wordpress/\", \"text\": \"WordPress\"}, {\"link\": \"https://www.sitepoint.com/mobile/\", \"text\": \"Mobile\"}, {\"link\": \"https://www.sitepoint.com/programming/\", \"text\": \"Programming\"}, {\"link\": \"https://www.sitepoint.com/python/\", \"text\": \"Python\"}, {\"link\": \"https://www.sitepoint.com/ai/\", \"text\": \"AI\"}, {\"link\": \"https://www.sitepoint.com/author/mbiss/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/author/mbiss/\", \"text\": \"Madars Biss\"}, {\"link\": \"https://www.sitepoint.com/author/mbiss/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/author/mbiss/\", \"text\": \"Madars Biss\"}, {\"link\": \"https://www.sitepoint.com/chatgpt-build-simple-spellchecker/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/chatgpt-build-simple-spellchecker/\", \"text\": \"How to Build a Simple Spellchecker with ChatGPT\"}, {\"link\": \"https://www.sitepoint.com/author/jcharlesworth/\", \"text\": \"James Charlesworth\"}, {\"link\": \"https://www.sitepoint.com/openai-api-python-data-analysis/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/openai-api-python-data-analysis/\", \"text\": \"How to Perform Data Analysis in Python Using the OpenAI API\"}, {\"link\": \"https://www.sitepoint.com/author/mnikonorov/\", \"text\": \"Matt Nikonorov\"}, {\"link\": \"https://www.sitepoint.com/create-data-trained-chatbot-openai-api/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/create-data-trained-chatbot-openai-api/\", \"text\": \"Create a Chatbot Trained on Your Own Data via the OpenAI API\"}, {\"link\": \"https://www.sitepoint.com/author/mnikonorov/\", \"text\": \"Matt Nikonorov\"}, {\"link\": \"https://www.sitepoint.com/javascript-chatgpt-plugin/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/javascript-chatgpt-plugin/\", \"text\": \"Build Your First JavaScript ChatGPT Plugin\"}, {\"link\": \"https://www.sitepoint.com/author/mark-oneill/\", \"text\": \"Mark O'Neill\"}, {\"link\": \"https://www.sitepoint.com/react-harperdb-build-hacker-news-clone/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/react-harperdb-build-hacker-news-clone/\", \"text\": \"Build a Hacker News Clone using React and HarperDB\"}, {\"link\": \"https://www.sitepoint.com/author/kubah/\", \"text\": \"Kingsley Ubah\"}, {\"link\": \"https://www.sitepoint.com/reddit-clone-react-firebase/\", \"text\": \"\"}, {\"link\": \"https://www.sitepoint.com/reddit-clone-react-firebase/\", \"text\": \"How to Create a Reddit Clone Using React and Firebase\"}, {\"link\": \"https://www.sitepoint.com/author/nghosh/\", \"text\": \"Nirmalya Ghosh\"}, {\"link\": \"https://www.sitepoint.com/premium/library/\", \"text\": \"Premium\"}, {\"link\": \"https://www.sitepoint.com/newsletters/\", \"text\": \"Newsletters\"}, {\"link\": \"https://www.sitepoint.com/community/\", \"text\": \"Forums\"}, {\"link\": \"https://www.sitepoint.com/about-us/\", \"text\": \"Our story\"}, {\"link\": \"https://www.sitepoint.com/legals/\", \"text\": \"Terms of use\"}, {\"link\": \"https://www.sitepoint.com/privacy-policy/\", \"text\": \"Privacy policy\"}, {\"link\": \"https://www.sitepoint.com/premium-for-teams/\", \"text\": \"Corporate memberships\"}, {\"link\": \"https://www.sitepoint.com/contact-us/\", \"text\": \"Contact us\"}, {\"link\": \"https://www.sitepoint.com/write-for-us/\", \"text\": \"Write an article for us\"}, {\"link\": \"https://www.sitepoint.com/partnerships/\", \"text\": \"Advertise\"}, {\"link\": \"https://www.sitepoint.com/sitepoint.rss\", \"text\": \"\"}]",
    "priceAndPlans": "Error: Timeout 30000ms exceeded. =========================== logs\n=========================== navigating to\n\"http://web.archive.org/web/20240112054149/https://www.sitepoint.com/\",\nwaiting until \"load\"\n============================================================\n\n"
}