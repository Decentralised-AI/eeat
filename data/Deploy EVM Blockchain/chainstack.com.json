{
    "summary": "**We now support**\n\nRonin\n\n**on Mainnet and Saigon Testnet.   _Find out more_**\n\n  * Product\n    *     * Chains\n      * Ethereum\n      * Polygon\n      * BNB Smart Chain\n      * Base\n      * Avalanche\n      * Arbitrum\n      * zkSync Era\n      * Polygon zkEVM\n      * Optimism\n      * Oasis Sapphire\n      * NEAR\n      * Aurora\n      * Solana\n      * Scroll\n      * Ronin\n      * Aptos\n      * Gnosis Chain\n      * Cronos\n      * Filecoin\n      * Fantom\n      * Starknet\n      * Harmony\n      * Tezos\n      * Bitcoin\n      * Fabric\n      * Corda\n      * See all chains \n    * Core\n      * Elastic Nodes World\u2019s most reliable Web3 API designed to deliver unbounded performance\n\n      * Dedicated Nodes Bespoke Web3 development setup unrestrained by per-request billing or hosting options\n\n      * Account Abstraction Bundler API for ERC-4337 transactions\n\n    * Appchains\n      * Avalanche Subnets Deploy and run your own chain secured by a set of Avalanche validators\n\n      * Polygon CDK Deploy and run your own ZK L2 with Polygon CDK\n\n      * Starknet Appchains Deploy and run your own Starknet Appchain\n\n      * zkSync Hyperchains Deploy and run your own zkSync Hyperchain\n\n    * Data\n      * Subgraphs Fast and reliable indexing solution and hosting for your subgraphs\n\n      * NFT API Fetch, search, mint, and manage NFTs\n\n      * DeFi API Low-code gateway to query DeFi data\n\n    * Storage\n      * IPFS Store and distribute digital assets with truly decentralized IPFS storage\n\n    * Hosting\n      * Hosting options Deploy nodes on any cloud with our globally distributed infrastructure\n\n      * Chainstack cloud Enjoy the highest performance, stability, and security with our native cloud\n\n    * Use cases\n      * Web3 builders\n\n      * Software studios\n\n      * Traders\n\n      * NFTs\n\n      * Gaming\n\n  * Pricing\n  * Enterprise\n  * Customers\n  * Blog\n  * Developers\n    *     * Get started\n      * Platform docs Introduction to the Chainstack platform for instant kick-off\n\n      * Blockchain node API references Use RPC methods to interact with blockchain data\n\n      * Subgraphs Learn how to index and query blockchain data \n\n      * Become an ambassador\n\n    * Guides\n      * Web3 [De]Coded BUIDL your DApp with our developer tutorials: from newbie to pro\n\n      * Recipes Step-by-step code walkthroughs for the most popular API use cases\n\n      * Blog Unravel Web3 and learn the latest news in the space\n\n    * Resources\n      * Labs\n\n      * Faucet\n\n      * Marketplace\n\n      * Release notes\n\n      * Status\n\n      * Help centre\n\nLog in\n\nStart for free\n\nLog in\n\nStart for free\n\n#  Deploying a deterministic smart contract on Ethereum\n\nBastian Simpertigue\n\nJuly 19, 2022\n\naddressescreate2EthereumRemixsmart contracttestnetWeb3\n\n## Introduction\n\nDeployment of a new contract on an EVM-based protocol usually produces a\ncontract address that cannot be known in advance. Fortunately, a way of\nprecomputing a contract address was introduced in EIP-1014.\n\nIn this post we will explore:\n\n  * How a contract address is usually generated.\n  * How you can know a contract address before deploying a new contract instance.\n  * What the advantages and use cases of deterministic deployment are.\n\nThis article works for most EVM-based protocols\u2014Ethereum, Polygon, BNB Smart\nChain, Avalanche C-Chain, Fantom, Harmony, and others.\n\n## Deploying a smart contract\u2014the classic way\n\nWhenever a new contract is deployed to an EVM-based network classically, a\ncouple of variables are used to generate the contract address, resulting in\n**different addresses for the same deployer and the same contract**. Even\nthough every contract address is deployed deterministically, the main\ndifference between the classic way and the approach we will see later is the\nuse of different creation functions.\n\nClassically, the  **address of a smart contract is computed using the deployer\naddress (sender) and the number of transactions sent by this account**\n**(nonce)**. The deployer and the nonce are RLP-encoded and hashed with\nKeccak-256.  \n\nAn example function from pyethereum:\n\n    \n    \n    def mk_contract_address(sender, nonce): \n        return sha3(rlp.encode([normalize_address(sender), nonce]))[12:] \n\nThis way, even when having the same account and the same smart contract code,\nthe address of this contract will change if we choose to re-deploy it. But\nthere is a way to precompute a contract address and use this address to\nperform transactions\u2014like sending ETH to it\u2014even when this address has nothing\nin it yet.\n\n## Deploying a smart contract\u2014the deterministic way\n\nThere are a number of approaches to generate a deterministic address for a\nsmart contract\u2014for example, one that seeks to lower gas costs, and older ways\nby using assembly code. However, newer approaches are available just by using\nsmart contract functions and a factory contract approach.\n\nFirst, let us write a simple smart contract that returns its balance and uses\nthe deployer address as the constructor parameter. The contract can also store\nfunds and allow the contract owner to withdraw the funds. This will be useful\nin the future.\n\n    \n    \n    // SPDX-License-Identifier: MIT\n    pragma solidity ^0.8.13;\n    contract SimpleWallet {\n        address public owner;\n        // Only owners can call transactions marked with this modifier\n        modifier onlyOwner() {\n            require(owner == msg.sender, \"Caller is not the owner\");\n            _;\n        }\n        constructor(address _owner) payable {\n            owner = _owner;\n        }\n        // Allows the owner to transfer ownership of the contract\n        function transferOwnership(address _newOwner) external onlyOwner {\n            owner = _newOwner;\n        }\n        // Returns ETH balance from this contract\n        function getBalance() public view returns (uint256) {\n            return address(this).balance;\n        }  \n        // Allows contract owner to withdraw all funds from the contract\n        function withdraw() external onlyOwner {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n        // Destroys this contract instance\n        function destroy(address payable recipient) public onlyOwner {\n            selfdestruct(recipient);\n        }\n    }\n\nWhat if we deploy this contract just like this? Let\u2019s use Remix for simplicity\nand deploy the contract on Goerli.\n\nFirst, select **Injected Web3** and be sure to have a wallet extension such as\nMetaMask. You can also check this plugin to deploy contracts on Remix from\nyour local environment.\n\nOnce you\u2019ve done that, add your Ethereum Goerli endpoint to MetaMask. You can\nget a free public node from Chainstack.\n\nNow, let\u2019s deploy the contract, be sure that your network selected on MetaMask\nis correct:\n\nAlso, you will need to fund your account with some ETH on Goerli from a\nfaucet.\n\nYou can now deploy the contract.\n\nClick on your account address from MetaMask to copy it to clipboard and then\npass it as argument to the Remix deployment option.\n\nFor example, **Deploy** : `0x06908fDbe4a6af2BE010fE3709893fB2715d61a6`\n\nOnce the transaction gets mined, you can check the output from Remix. Also,\nyou can check your transactions on MetaMask, select the last one. It should\nsay `Contract Deployment`. You can always refer to the Chainstack article on\nhow MetaMask transactions work.\n\nOnce you click on it, it will display a few details of the transaction. Let us\nclick on **View on block explorer**. This will open Etherscan, so we can see\ncheck our contract creation in depth.\n\nWe can see that a new instance of our SimpleWallet contract was created on\naddress `0x4388C588f2a28343dB614FFd3817eE5459f85760`. Notice that we didn\u2019t\nknow in advance what address would be generated, and only when the contract\nwas created and the transaction mined it was provided.\n\nWhat if we can **precompute a contract address prior to its deployment** and\nperform operations like sending funds to it, and then allow someone to get\nback those funds only **when the contract gets deployed**? We can achieve this\nby using the CREATE2 function.\n\nLet\u2019s create a factory contract that also has the `SimpleWallet` contract and\nthat will use the CREATE2 opcode as stated in Solidity docs: Salted contract\ncreations / create2.\n\n    \n    \n    // SPDX-License-Identifier: MIT\n    pragma solidity ^0.8.0;\n    contract SimpleWallet {\n        address public owner;\n        // Only owners can call transactions marked with this modifier\n        modifier onlyOwner() {\n            require(owner == msg.sender, \"Caller is not the owner\");\n            _;\n        }\n        constructor(address _owner) payable {\n            owner = _owner;\n        }\n        // Allows the owner to transfer ownership of the contract\n        function transferOwnership(address _newOwner) external onlyOwner {\n            owner = _newOwner;\n        }\n        // Returns ETH balance from this contract\n        function getBalance() public view returns (uint256) {\n            return address(this).balance;\n        }\n        // Allows contract owner to withdraw all funds from the contract\n        function withdraw() external onlyOwner {\n            payable(msg.sender).transfer(address(this).balance);\n        }\n        // Destroys this contract instance\n        function destroy(address payable recipient) public onlyOwner {\n            selfdestruct(recipient);\n        }\n    }\n    contract Factory {\n        // Returns the address of the newly deployed contract\n        function deploy(\n            uint _salt\n        ) public payable returns (address) {\n            // This syntax is a newer way to invoke create2 without assembly, you just need to pass salt\n            // https://docs.soliditylang.org/en/latest/control-structures.html#salted-contract-creations-create2\n            return address(new SimpleWallet{salt: bytes32(_salt)}(msg.sender));\n        }\n        // 1. Get bytecode of contract to be deployed\n        function getBytecode()\n            public\n            view\n            returns (bytes memory)\n        {\n            bytes memory bytecode = type(SimpleWallet).creationCode;\n            return abi.encodePacked(bytecode, abi.encode(msg.sender));\n        }\n        /** 2. Compute the address of the contract to be deployed\n            params:\n                _salt: random unsigned number used to precompute an address\n        */ \n        function getAddress(uint256 _salt)\n            public\n            view\n            returns (address)\n        {\n            // Get a hash concatenating args passed to encodePacked\n            bytes32 hash = keccak256(\n                abi.encodePacked(\n                    bytes1(0xff), // 0\n                    address(this), // address of factory contract\n                    _salt, // a random salt\n                    keccak256(getBytecode()) // the wallet contract bytecode\n                )\n            );\n            // Cast last 20 bytes of hash to address\n            return address(uint160(uint256(hash)));\n        }\n    }\n\nLet\u2019s deploy this factory contract on Goerli using Remix again. We are\ndeploying the contract the classic way so that we can later use it to\nprecompute the deployment address.\n\nAgain, select the deployment options in Remix and switch the contract to be\ndeployed to `Factory`. Once the right contract is selected, deploy it.\n\nOnce the deployment gets confirmed, select the deployed contract to expand it\nand check its available functions. Example of a deployed factory contract.\n\nOur motivation is now to deploy a new instance of our `SimpleWallet` contract,\nbut knowing its contract address in advance. Fortunately, our `Factory` __\ncontract allows us to precompute this address.\n\nThe **getAddress** function returns a precomputed address of a new\n`SimpleWallet` instance. It requires a `salt` __ parameter in order to return\nthis address. For simplicity we will use `123` as salt, but it cant be any\nuint256 value. It\u2019s important to note that, if you\u2019re **using your own\ndeployed Factory contract the addresses wont be the same** , as the\n**getAddress** __ function utilizes the Factory contract instance address to\ncompute new `SimpleWallet` instance addresses. However, you **can still use\nthe one that has been deployed in this tutorial** and (if using the same salt)\nget the same address as result.\n\nLet\u2019s pass `123` as argument to the **getAddress** __ function and execute it\nfrom Remix.\n\nIn this particular example the precomputed address is\n`0xf49521d876d1add2D041DC220F13C7D63c10E736`.\n\nNow that we know in advance at which contract address our `SimpleWallet` will\nbe deployed through our `Factory` contract, let\u2019s send some funds to it. Don\u2019t\nworry if nothing exists yet in there, we will recover our funds later.\n\nGo to MetaMask, input the contract address that was returned by the\n**getAddress** __ function and send some ETH.\n\nNow, let\u2019s actually deploy our `SimpleWallet` __ instance and check if it\u2019s\ncorrectly deployed to our precomputed address. In Remix, search for the\n**Deploy** __ function in our `Factory` __ contract instance and pass `123` __\nas salt. Wait for the transaction and head to Etherscan to confirm that it\ndeployed correctly.\n\nIn the transaction details section (on Etherscan) select the `Internal Txns`\ntab.\n\nOnce there, we see that the **CREATE2 function was called from our Factory\ncontract** , and a new instance of our `SimpleWallet` __ contract was created.\nClick on the address of the created contract and check that the address is the\nsame that was precomputed previously.\n\nNote that because Etherscan seems to be running OpenEthereum nodes on Goerli,\nCREATE2 is rendered as CREATE in the Etherscan interface. See OpenEthereum\nIssue 10922.\n\nIf everything was correct, we should be able to withdraw the amount of ETH\nthat we sent to our `SimpleWallet` __ contract. But first, we need a way to\ninteract with it.\n\nFor simplicity, you can also verify the contract on Etherscan, connect to it\nusing MetaMask and withdraw the funds.\n\nContract in our example.\n\n## Interacting with our smart contract\n\nTo be able to retrieve our funds, we need a way to interact with our\n`SimpleWallet` __ contract.\n\nFirst, let\u2019s start a new Node.js project and install some required packages.\n\n    \n    \n    mkdir deterministic-deployment-factory && cd deterministic-deployment-factory\n    npm init --y\n    npm i ethers\n\nCreate a new file called `SimpleWalletAbi.js` and paste the following content.\nThis file will serve as interface to our contract so we can interact with it\nusing the ethers.js library.\n\n    \n    \n    const abi =  [\n        {\n            \"inputs\": [\n                {\n                    \"internalType\": \"address\",\n                    \"name\": \"_owner\",\n                    \"type\": \"address\"\n                }\n            ],\n            \"stateMutability\": \"payable\",\n            \"type\": \"constructor\"\n        },\n        {\n            \"inputs\": [\n                {\n                    \"internalType\": \"address payable\",\n                    \"name\": \"recipient\",\n                    \"type\": \"address\"\n                }\n            ],\n            \"name\": \"destroy\",\n            \"outputs\": [],\n            \"stateMutability\": \"nonpayable\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [],\n            \"name\": \"getBalance\",\n            \"outputs\": [\n                {\n                    \"internalType\": \"uint256\",\n                    \"name\": \"\",\n                    \"type\": \"uint256\"\n                }\n            ],\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [],\n            \"name\": \"owner\",\n            \"outputs\": [\n                {\n                    \"internalType\": \"address\",\n                    \"name\": \"\",\n                    \"type\": \"address\"\n                }\n            ],\n            \"stateMutability\": \"view\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [\n                {\n                    \"internalType\": \"address\",\n                    \"name\": \"_newOwner\",\n                    \"type\": \"address\"\n                }\n            ],\n            \"name\": \"transferOwnership\",\n            \"outputs\": [],\n            \"stateMutability\": \"nonpayable\",\n            \"type\": \"function\"\n        },\n        {\n            \"inputs\": [],\n            \"name\": \"withdraw\",\n            \"outputs\": [],\n            \"stateMutability\": \"nonpayable\",\n            \"type\": \"function\"\n        }\n    ];\n    module.exports = {\n        abi\n    }\n\nNow, let\u2019s create our `index.js` file and add the initial configuration\nrequired to interact with the contract\n\n    \n    \n    const { ethers } = require(\"ethers\");\n    const { abi } = require(\"./SimpleWalletAbi\");\n    const PRIVATE_KEY =\n      \"<YOUR_PRIVATE_KEY>\";\n    const simpleWalletAddress = \"<YOUR_INSTANCE_ADDRESS>\";\n    const main = async () => {\n      // Inits a new ethers object with a provider\n      const provider = ethers.getDefaultProvider(\n        \"<YOUR_GOERLI_PROVIDER>\"\n      );\n      // Inits a new ethers wallet to send transactions\n      const signer = new ethers.Wallet(PRIVATE_KEY, provider);\n      // Inits a new SimpleWallet instance\n      const simpleWallet = new ethers.Contract(simpleWalletAddress, abi, signer);\n    }\n    main();\n\nGood time to remind that you can get a free public node from Chainstack for\nyour Goerli endpoint.  \nOnce our initial configuration is done, let\u2019s check that everything is in\norder and we get no errors by running the script.\n\n    \n    \n    node index.js\n\nNow, let\u2019s add a simple query to fetch the contract balance. In this example\nwe sent 0.2 GoerliETH to the contract, so it should show correctly the amount\nsent.\n\n    \n    \n    const { ethers } = require(\"ethers\");\n    const { abi } = require(\"./SimpleWalletAbi\");\n    const PRIVATE_KEY = \"<YOUR_PRIVATE_KEY>\";\n    const simpleWalletAddress = \"<YOUR_INSTANCE_ADDRESS>\";\n    const main = async () => {\n      // Inits a new ethers object with a provider\n      const provider = ethers.getDefaultProvider(\"<YOUR_GOERLI_PROVIDER>\");\n      // Inits a new ethers wallet to send transactions\n      const signer = new ethers.Wallet(PRIVATE_KEY, provider);\n      // Inits a new SimpleWallet instance\n      const simpleWallet = new ethers.Contract(simpleWalletAddress, abi, signer);\n      // Query the balance of the contract by calling\n      // the getBalance function\n      provider.getBalance(simpleWalletAddress).then((balance) => {\n     // convert a currency unit from wei to ether\n     const balanceInEth = ethers.utils.formatEther(balance)\n     console.log(`Current balance in SimpleWallet: ${balanceInEth} ETH`)\n    })\n    };\n    main();\n\nRunning the script again should now output the current balance in our\n`SimpleWallet`.\n\nNow, let\u2019s actually recover the funds stored in the contract. Add the\nfollowing code to the script and run it again. We should expect to receive the\nETH stored in the contract and the contracts balance updated later.\n\n    \n    \n    const { ethers } = require(\"ethers\");\n    const { abi } = require(\"./SimpleWalletAbi\");\n    const PRIVATE_KEY = \"<YOUR_PRIVATE_KEY>\";\n    const simpleWalletAddress = \"<YOUR_INSTANCE_ADDRESS>\";\n    const main = async () => {\n      // Inits a new ethers object with a provider\n      const provider = ethers.getDefaultProvider(\"<YOUR_GOERLI_PROVIDER>\");\n      // Inits a new ethers wallet to send transactions\n      const signer = new ethers.Wallet(PRIVATE_KEY, provider);\n      // Inits a new SimpleWallet instance\n      const simpleWallet = new ethers.Contract(simpleWalletAddress, abi, signer);\n      // Withdraw funds from the contract\n      try {\n        console.log(\"Attempting to withdraw funds...\");\n        const receipt = await simpleWallet.withdraw();\n        console.log(\"Funds withdrawn! :)\");\n        console.log(receipt);\n      } catch (error) {\n        console.log(\"Funds can't be withdrawn\");\n        console.error(error);\n      }\n      // Query the balance of the contract by calling\n      // the getBalance function\n      provider.getBalance(simpleWalletAddress).then((balance) => {\n     // convert a currency unit from wei to ether\n     const balanceInEth = ethers.utils.formatEther(balance)\n     console.log(`Current balance in SimpleWallet: ${balanceInEth} ETH`)\n    })\n    };\n    main();\n\nRun the script one last time. Once the transaction succeeds, the funds will be\nwithdrawn back to your address and the contract balance will show `0`.\n\nIn case you need it, the complete code can be found in the blog\u2019s repository.\n\n## Wrap up\n\nPrecomputing the address of a contract may **increase the security and\nreliability** of decentralized applications since the code in the smart\ncontract is (generally) the same and will not change. It also allows to\n**deploy a recreated version of a contract to the same address** after it has\nbeen destroyed in case things get messed up. More important it allows to\nimplement **use cases for counterfactual interactions** with code that has\nbeen created by a particular piece of init code that can be even generated\noff-chain.\n\nIn this post we have reviewed a great topic about the ability to set a\ndeterministic address for our smart contracts. We have included some great\npoints on top of it:\n\n  * How a contract address is usually generated.\n  * How can we know a contract address before deploying a new contract instance.\n  * What are the advantages and use cases of deterministic deployment.\n\n## Power-boost your project on Chainstack\n\n  * Discover how you can save thousands in infra costs every month with our unbeatable pricing on the most complete Web3 development platform.\n  * Input your workload and see how affordable Chainstack is compared to other RPC providers.\n  * Connect to Ethereum, Polygon, BNB Smart Chain, Base, Avalanche, Arbitrum, zkSync Era, Polygon zkEVM, Optimism, Oasis Sapphire, NEAR, Aurora, Solana, Scroll, Aptos, Gnosis Chain, Cronos, Filecoin, Fantom, StarkNet, Harmony and Tezos mainnet or testnets through an interface designed to help you get the job done.\n  * To learn more about Chainstack, visit our Developer Portal or join our Discord server and Telegram group. \n  * Are you in need of testnet tokens? Request some from our faucets. Multi-chain faucet, Sepolia faucet, Goerli faucet, Holesky faucet, BNB faucet, zkSync faucet, Scroll faucet.\n\nHave you already explored what you can achieve with Chainstack? Get started\nfor free today.\n\nSHARE THIS ARTICLE\n\n### Introduction\n\n### Deploying a smart contract\u2014the classic way\n\n### Deploying a smart contract\u2014the deterministic way\n\n### Interacting with our smart contract\n\n### Wrap up\n\n### Power-boost your project on Chainstack\n\n###  Unicrypt on Chainstack: Setting a stable foundation for incubating\nblockchain initiatives\n\nUnicrypt successfully eliminated block synchronization issues with smooth\nnetwork performance and an affordable pricing structure.\n\nPetar Stoykov\n\nApr 29\n\n###  Avalanche subnets tutorial series: Avalanche smart contracts\n\nPart 4 of the Avalanche subnet tutorial series. It is about deploying smart\ncontract on subnet blockchains using Remix and MetaMask.\n\nWuzhong Zhu\n\nApr 25\n\n###  See Chainstack in action\n\nManaged blockchain services making it simple to launch and scale decentralized\nnetworks and applications.\n\nStart for free\n\n### Never miss an update\n\nOur monthly newsletter is the perfect way to stay up-to-date with the latest\nindustry news, product updates, and exclusive promotions.\n\nEmail*\n\nBy ticking this box you give Chainstack your consent to store and process your\nemail address to send you updates. You can unsubscribe from our communications\nat any time, more details on our T&C and Privacy Policy.\n\n  * I agree to receive communications from Chainstack*\n\n**United States**  \n1 Van de Graaff Drive  \nBurlington, MA  \n01803  \n  \n**Singapore**  \n8 Temasek Boulevard  \n#30-01/02, Suntec Tower 3  \n038988\n\nChainstack \u00a9 2024\n\n### Platform\n\n  * Solution\n  * Pricing\n  * Customers\n  * Marketplace\n  * Hosting\n  * Chainstack Cloud\n  * NFT API\n  * IPFS\n  * Subgraphs\n\n### Chains\n\n  * Ethereum\n  * Polygon\n  * BNB Smart Chain\n  * Avalanche\n  * Arbitrum\n  * zkSync Era\n  * Polygon zkEVM\n  * Optimism\n  * Oasis Sapphire\n  * NEAR\n  * Aurora\n  * Solana\n  * Scroll\n  * Ronin\n  * Aptos\n  * Gnosis Chain\n  * Cronos\n  * Filecoin\n  * Fantom\n  * Starknet\n  * Harmony\n  * Tezos\n  * Bitcoin\n  * Hyperledger Fabric\n  * Quorum\n  * Corda\n  * MultiChain\n\n### Resources\n\n  * Blog\n  * Newsletter\n  * Newsroom\n  * Press kit\n\n### Company\n\n  * About us\n  * Contact us\n  * Careers\n  * Ambassadors\n  * Labs\n  * Security\n  * SLA\n\n### Support\n\n  * Help center\n  * Developer portal\n  * Terms of service\n  * Privacy policy\n  * Status\n  * Cookie settings\n\n",
    "links": "[{\"link\": \"https://chainstack.com/build-better-with-ronin-nodes/\", \"text\": \"\"}]"
}